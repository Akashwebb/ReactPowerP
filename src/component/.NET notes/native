Handling Concurrent Data Fetching and Updates:

# What is  native modules ?

Native modules in React Native are custom functionalities written in native code (such as Objective-C/Swift for iOS and Java/Kotlin for Android) that can be called from JavaScript. They allow you to extend the capabilities of a React Native app by using features that are not available in the standard React Native APIs. This is especially useful for accessing device-specific features or integrating with third-party native SDKs.

# Creating and Using a Native Module

@ IoS
1. Create the Native Module Files:
Create a new file MyModule.m and MyModule.h in the ios directory.
2. Define the Module Interface (MyModule.h):
3. Implement the Module (MyModule.m)
4. Use the Native Module in JavaScript

@Android
1. Create the Native Module Files:
Create a new file MyModule.java in the android/app/src/main/java/com/yourproject directory.
2. Define the Module (MyModule.java)
3. Create a Package for the Module (MyPackage.java)
4. Modify the MainApplication.java file to include the new package.

# Native Module && Native Component  
1. Native Module:
Focuses on functionality.
Bridges non-UI, platform-specific APIs to JavaScript.
Examples: Accessing sensors, performing native calculations, invoking native services.

2. Native Component:
Focuses on UI.
Bridges custom, platform-specific UI elements to JavaScript.
Examples: Custom buttons, specialized map views, platform-specific animations.

# Location Access
To get the location of a user in a React Native application, you can use the react-native-geolocation-service library, which provides access to the device's location services
-->   npm install react-native-geolocation-service
-->   npx react-native link react-native-geolocation-service

1. The <hasLocationPermission function> checks if the app has the necessary location permissions. If not, it requests them.

2. The <getLocation function> checks for permission and then uses <Geolocation.getCurrentPosition> to get the user's current location.

3. Permissions Configuration:
iOS permissions are specified in the <Info.plist file>
Android permissions are specified in the <AndroidManifest.xml>

# Other ways to get location:
1. Built-in Geolocation API: Simple and built-in, but may have limitations.
2. React-native-geolocation-service: A more reliable and feature-rich library.
3. React-native-location: Provides advanced features for location tracking.
4. Expo-location: Best for Expo-managed projects with simplified API and permissions handling.

------------------------------------------------------------------------------------------------------

#  FlatList and ScrollView 
FlatList is optimized for handling large data sets and provides better performance with features like lazy loading, Optimize rendering with React.memo and PureComponent to avoid unnecessary updates.
whereas ScrollView renders all items at once and can be inefficient for long lists.

# Scenario: Handling Error Boundaries

Problem: Your React Native app experiences occasional crashes or errors due to unexpected issues in the component tree.

Question: How would you implement error boundaries to handle and recover from these errors?

Answer:

Implement error boundaries using componentDidCatch in class components or the ErrorBoundary component in functional components.
Provide a fallback UI or error message to inform users about issues.
Log errors to an external service or monitoring tool for debugging and analysis.
Test error boundaries thoroughly to ensure they handle various types of errors gracefully.


# I have a application where i want my data to update in real time , how we do in react native

1. Using WebSockets :  WebSockets provide a full-duplex communication channel over a single, long-lived connection, making them ideal for real-time data updates.
  # npm install @react-native-community/netinfo

2. Firebase Realtime Database / Firestore :  Firebase provides a real-time database and Firestore, both of which can be used to sync data in real-time.  
  # npm install @react-native-firebase/app @react-native-firebase/firestore

3. Polling
4. GraphQL Subscriptions

<!-- --------------------------------------------------------------------------------------------- -->
<!-- --------------------------------------------------------------------------------------------- -->


# Expo CLI and React Native CLI are tools used for developing React Native applications, but they serve slightly different purposes and cater to different development needs.

Use Expo CLI if:

You are new to React Native.
You want to quickly prototype or build an app with standard features.
You prefer a simpler, managed development process.
Use React Native CLI if:

You need full control over the native code.
You need to use custom native modules or advanced native features.
You are integrating with an existing native app or have specific native requirements.


<!-- ------------------------------------------------------------------------------------------------- -->

# Key React Native APIs

# Platform-Specific Components:
TouchableOpacity, TouchableHighlight, TouchableWithoutFeedback: For handling touch interactions.
Picker: Dropdown menu for selecting items (deprecated in favor of third-party libraries like @react-native-picker/picker).


# APIs for Accessing Native Modules:
Platform: To differentiate code between iOS and Android.
Dimensions: For getting screen dimensions.
PixelRatio: For managing pixel density.
AppState: For detecting the state of the app (foreground, background, inactive).

# Device APIs:
CameraRoll: Access the camera roll or photo library (deprecated, use react-native-cameraroll).
Geolocation: Access the device’s location (deprecated, use react-native-geolocation-service).
Vibration: Trigger the device’s vibration.
Clipboard: Interact with the system clipboard.
PushNotificationIOS: Handle push notifications on iOS (use @react-native-community/push-notification-ios).


----------------------------------------------------------------------------------------------------

Scenario
# You are building a real-time collaborative text editor using React. The editor allows multiple users to edit the same document simultaneously. The application fetches initial document data from a server and listens for real-time updates through a WebSocket connection. Users can apply formatting (bold, italic, underline) to selected text. The application needs to be highly performant and responsive, even with multiple simultaneous users.

1. Initial Data Fetch
Use useEffect to fetch initial data when the component mounts.

2. Real-time Updates
Use a WebSocket connection to handle real-time updates. Manage updates efficiently to avoid unnecessary re-renders.

3. Text Formatting
Implement text formatting using a context menu or toolbar with buttons for bold, italic, and underline. Apply formatting to selected text.

4. Performance Optimization
Use useMemo and useCallback hooks to optimize rendering and prevent unnecessary updates. Use React.memo for memoizing components.

5. State Management
Use useReducer for complex state management.


------------------------------------------------------------------------------------------------------

# I bought a new laptop and now i want to develop my first react native application as "hello world"  , 
1. what are the software i need to install    
2. what will be the code 
3. software to test my application
4. how to deploy it in play store 
make it short and to the  point for Android only 

# SOFTWARE
1. Node.js: Download and install Node.js from nodejs.org. This will include npm (Node Package Manager).
2. Java Development Kit (JDK): Install JDK (Java SE Development Kit) from Oracle.
3. Android Studio: Download and install Android Studio from developer.android.com.
4. Android SDK: Install Android SDK through Android Studio. Ensure you install the necessary SDK tools and system images.
5. React Native CLI: Install React Native CLI using npm.
   ** npm install -g react-native-cli

# Create and Code the Application   
1. Create a New React Native Project:
    ** npx react-native init HelloWorldApp
       cd HelloWorldApp

2. Modify App.js for "Hello World"

# Software to Test the Application

1. Run the Application on Android Emulator or Device
     **  npx react-native run-android

# Deploy to Play Store

1. Generate a Signed APK:
   keytool -genkey -v -keystore my-release-key.keystore -keyalg RSA -keysize 2048 -validity 10000 -alias my-key-alias
# Why is it Necessary?
=> Signing the APK: Android requires that all APKs be digitally signed with a certificate before they can be installed on a device or uploaded to the Google Play Store. This signing process provides proof of the app's authenticity and integrity.

=> Generating a Key and Keystore: The command generates a keystore file containing a private key and a certificate. This keystore is used to sign your APK. The private key is used to generate a signature, and the certificate is included in the APK for verification purposes.

=> Security and Updates: Once an app is signed with a keystore, all future updates to that app must be signed with the same keystore. This ensures that updates are indeed from the same developer and haven't been tampered with.

2. Set up Gradle for Signing: Modify android/app/build.gradle to include the signing configuration. 

3. Build the Signed APK:
    cd android
    ./gradlew assembleRelease

4. Upload to Google Play Console:

Log in to the Google Play Console.
Create a new application.
Upload the signed APK located at android/app/build/outputs/apk/release/app-release.apk.

----------------------------------------------------------------------------------------------------

# Creating an APK file of react native application in ANDROID 

1. Navigate to the Android directory:
cd android

2. Ensure build.gradle has the signing configuration:

android {
    ...
    signingConfigs {
        release {
            keyAlias 'your-key-alias'
            keyPassword 'your-key-password'
            storeFile file('path/to/my-release-key.keystore')
            storePassword 'your-keystore-password'
        }
    }
    buildTypes {
        release {
            signingConfig signingConfigs.release
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

3. Run the build command:
./gradlew assembleRelease

4. Locate your APK:
android/app/build/outputs/apk/release/app-release.apk

<!-- ----------------------------------------------------------------------------------------------- -->
<!-- ------------------------------------------------------------------------------------------------ -->

######  iOS  #####

# Software to Install
1. macOS: Ensure you are using a Mac.
2. Node.js: Download and install Node.js from nodejs.org.
3. React Native CLI: Install React Native CLI using npm.
npm install -g react-native-cli
4. Xcode: Download and install Xcode from the Mac App Store.
5. CocoaPods: Install CocoaPods, a dependency manager for Swift and Objective-C.
sudo gem install cocoapods

# Create and Code the Application
1. Create a New React Native Project:
npx react-native init HelloWorldApp
cd HelloWorldApp
1. Modify App.js for "Hello World":
Replace the contents of App.js 

# Software to Test the Application

1. Install iOS Dependencies:
cd ios
pod install
cd ..

2. Run the Application on iOS Emulator:
npx react-native run-ios

# Deploy to the App Store

1. Open the Project in Xcode:
open ios/HelloWorldApp.xcworkspace

2. Configure Signing & Capabilities:
Select your project in the Project Navigator.
Go to the "Signing & Capabilities" tab.
Select your development team from the "Team" dropdown.

3. Archive the App:
Select "Any iOS Device (arm64)" as the target device.
Go to Product -> Archive.

4. Export the App:
In the Organizer window, select your archive.
Click Distribute App.
Select "App Store Connect" and follow the prompts to upload your app.

5. Upload to App Store Connect:
Go to App Store Connect.
Create a new app record.
Fill out the required information.
Submit your app for review.

